<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title></title>
		<description>叶斌的iOS Blog</description>
		<link>/</link>
		<atom:link href="/" rel="self" type="application/rss+xml" />
		
			<item>
				<title>学习html</title>
				<description>&lt;h1 id=&quot;html&quot;&gt;学习html&lt;/h1&gt;
&lt;p&gt;###标签link&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;html&amp;gt;  
	&amp;lt;head&amp;gt;  
		&amp;lt;title&amp;gt;第一个Html文档&amp;lt;/title&amp;gt;
	&amp;lt;/head&amp;gt;  
	&amp;lt;body&amp;gt;  
		欢迎访问&amp;lt;a href=&quot;http://kekeye.github.io&quot;叶斌的iOS Blog&amp;lt;/a&amp;gt;!  
	&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;font&quot;&gt;font&lt;/h3&gt;

&lt;p&gt;face 是字体   color是颜色  size是大小&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;font face=&quot;黑体&quot; color=&quot;blue&quot; size=&quot;30&quot;&amp;gt;叶斌 &amp;lt;br&amp;gt;&amp;lt;/font&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;加粗，下划线，斜体字也是常用的文字效果，它们分别用&lt;code&gt;&amp;lt;b&amp;gt; &amp;lt;u&amp;gt; &amp;lt;i&amp;gt;&lt;/code&gt;表示
&lt;code&gt;&amp;lt;b&amp;gt;Bold&amp;lt;/b&amp;gt;&amp;lt;i&amp;gt;italic&amp;lt;/i&amp;gt;&amp;lt;u&amp;gt;underline&amp;lt;/u&amp;gt;	&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;标题&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;h1&amp;gt;HTML 30分钟教程&amp;lt;/h1&amp;gt;
&amp;lt;h2&amp;gt;什么是HTML&amp;lt;/h2&amp;gt;
...
&amp;lt;h2&amp;gt;HTML是什么样的&amp;lt;/h2&amp;gt;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-1&quot;&gt;链接&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;标签用于在页面上添加横线。可以通过指定width和color属性来控制横线的长度和颜色。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;hr width=&quot;90%&quot; color=&quot;red&quot; /&amp;gt;	
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img /&gt;标签用于在页面上添加图片，src属性指定图片的地址，如果无法打开src指定的图片，浏览器通常会在页面上需要显示图片的地方显示alt属性定义的文本。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&quot;http://www.w3.org/Icons/valid-xhtml10&quot; alt=&quot;图片简介&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图片链接&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;a href=&quot;http://validator.w3.org&quot;&amp;gt;&amp;lt;img src=&quot;http://www.w3.org/Icons/valid-xhtml10&quot; alt=&quot;验证HTML&quot; /&amp;gt;&amp;lt;/a&amp;gt;	


&amp;lt;a href=&quot;http://www.w3school.com.cn/&quot; target=&quot;_blank&quot;&amp;gt;Visit W3School!&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-2&quot;&gt;分段与换行&lt;/h3&gt;

&lt;h3 id=&quot;section-3&quot;&gt;表格&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;table&amp;gt;  
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;2000&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;悉尼&amp;lt;/td&amp;gt;  
&amp;lt;/tr&amp;gt;
 &amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;2004&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;雅典&amp;lt;/td&amp;gt;  
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;2008&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;北京&amp;lt;/td&amp;gt;  
&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-4&quot;&gt;列表&lt;/h3&gt;
&lt;p&gt;表格用于表示二维数据（行，列），一维数据则用列表表示。列表可以分为无序列表（&amp;lt;ul&amp;gt;），有序列表（&amp;lt;ol&amp;gt;）和定义列表（&amp;lt;dl&amp;gt;）。前两种列表更常见一些，都用&amp;lt;li&amp;gt;标签包含列表项目。
无序列表表示一系列类似的项目，它们之间没有先后顺序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul&amp;gt;  
&amp;lt;li&amp;gt;苹果&amp;lt;/li&amp;gt;  
&amp;lt;li&amp;gt;桔子&amp;lt;/li&amp;gt;  
&amp;lt;li&amp;gt;桃&amp;lt;/li&amp;gt;  
&amp;lt;/ul&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有序列表中各个项目间的顺序是很重要的，浏览器通常会自动给它们产生编号。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ol&amp;gt;
&amp;lt;li&amp;gt;打开冰箱门&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;把大象赶进去&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;关上冰箱门&amp;lt;/li&amp;gt;
&amp;lt;/ol&amp;gt;	
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section-5&quot;&gt;框架&lt;/h3&gt;

&lt;p&gt;最后谈一下框架，曾经非常流行的技术，框架使一个窗口里能同时显示多个文档。主框架页里面没有&amp;lt;body&amp;gt;标签，取代它的是&lt;frameset&gt;。&lt;/frameset&gt;&lt;/p&gt;
&lt;frameset&gt;标签的属性Rows和Cols用于指定框架集(frameset)里有多少行（列），以及每行（列）的高度（宽度）。
&lt;frameset&gt;标签可以包含&lt;frame&gt;标签，每个&lt;frame&gt;标签代表一个文档（src属性指定文档的地址）。
如果觉得这样的页面还不够复杂的话，还可以在&lt;frameset&gt;标签里包含&lt;frameset&gt;标签。


	&lt;frameset rows=&quot;15%,*&quot;&gt;
     &amp;lt;frame src=&quot;top.html&quot; name=title scrolling=no&amp;gt;
     &lt;frameset cols=&quot;20%,*&quot;&gt;
          &amp;lt;frame src=&quot;left.html&quot; name=sidebar&amp;gt;
          &amp;lt;frame src=&quot;right.html&quot; name=recipes&amp;gt;
     &lt;/frameset&gt;
	&lt;/frameset&gt;
	
	

标签	描述
&lt;b&gt;	定义粗体文本。
&lt;big&gt;	定义大号字。
&lt;em&gt;	定义着重文字。
&lt;i&gt;	定义斜体字。
&lt;small&gt;	定义小号字。
&lt;strong&gt;	定义加重语气。
&lt;sub&gt;	定义下标字。
&lt;sup&gt;	定义上标字。
&lt;ins&gt;	定义插入字。
&lt;del&gt;	定义删除字。
&lt;s&gt;	不赞成使用。使用 &lt;del&gt; 代替。
&lt;strike&gt;	不赞成使用。使用 &lt;del&gt; 代替。
&lt;u&gt;	不赞成使用。使用样式（style）代替。	
	
	
&lt;/u&gt;&lt;/del&gt;&lt;/strike&gt;&lt;/del&gt;&lt;/s&gt;&lt;/del&gt;&lt;/ins&gt;&lt;/sup&gt;&lt;/sub&gt;&lt;/strong&gt;&lt;/small&gt;&lt;/i&gt;&lt;/em&gt;&lt;/big&gt;&lt;/b&gt;&lt;/frameset&gt;&lt;/frameset&gt;&lt;/frame&gt;&lt;/frame&gt;&lt;/frameset&gt;&lt;/frameset&gt;
</description>
				<pubDate>Sun, 09 Aug 2015 00:00:00 +0800</pubDate>
				<link>/2015/08/09/0%E5%AD%A6%E4%B9%A0Html.html</link>
				<guid isPermaLink="true">/2015/08/09/0%E5%AD%A6%E4%B9%A0Html.html</guid>
			</item>
		
			<item>
				<title>runtime</title>
				<description>&lt;h1 id=&quot;runtime&quot;&gt;runtime&lt;/h1&gt;
&lt;p&gt;Objective-C是基于C语言加入了面向对象特性和消息转发机制的动态语言，这意味着它不仅需要一个编译器，还需要Runtime系统来动态创建类和对象，进行消息发送和转发。下面通过分析Apple开源的Runtime代码来深入理解Objective-C的Runtime机制。&lt;/p&gt;

&lt;p&gt;Runtime数据结构
在Objective-C中，使用&lt;code&gt;[receiver message]&lt;/code&gt;语法并不会马上执行&lt;code&gt;receiver&lt;/code&gt;对象的&lt;code&gt;message&lt;/code&gt;方法的代码，而是向&lt;code&gt;receiver&lt;/code&gt;发送一条&lt;code&gt;message&lt;/code&gt;消息，这条消息可能由&lt;code&gt;receiver&lt;/code&gt;来处理，也可能由转发给其他对象来处理，也有可能假装没有接收到这条消息而没有处理。其实&lt;code&gt;[receiver message]&lt;/code&gt;被编译器转化为:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;id objc_msgSend ( id self, SEL op, ... );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面从两个数据结构&lt;code&gt;id&lt;/code&gt;和&lt;code&gt;SEL&lt;/code&gt;来逐步分析和理解Runtime有哪些重要的数据结构。&lt;/p&gt;

&lt;h2 id=&quot;sel&quot;&gt;SEL&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SEL&lt;/code&gt;是函数&lt;code&gt;objc_msgSend&lt;/code&gt;第二个参数的数据类型，表示方法选择器，按下面路径打开&lt;code&gt;objc.h&lt;/code&gt;文件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/166109-73bc4103f4b4e671.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;
***
	SEL Data Structure&lt;/p&gt;

&lt;p&gt;查看到SEL数据结构如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef struct objc_selector *SEL;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其实它就是映射到方法的C字符串，你可以通过Objc编译器命令&lt;code&gt;@selector()&lt;/code&gt;或者&lt;code&gt;Runtime&lt;/code&gt;系统的&lt;code&gt;sel_registerName&lt;/code&gt;函数来获取一个&lt;code&gt;SEL&lt;/code&gt;类型的方法选择器。
如果你知道&lt;code&gt;selector&lt;/code&gt;对应的方法名是什么，可以通过&lt;code&gt;NSString* NSStringFromSelector(SEL aSelector)&lt;/code&gt;方法将&lt;code&gt;SEL&lt;/code&gt;转化为字符串，再用&lt;code&gt;NSLog&lt;/code&gt;打印。&lt;/p&gt;

&lt;h2 id=&quot;id&quot;&gt;id&lt;/h2&gt;
&lt;p&gt;接下来看&lt;code&gt;objc_msgSend&lt;/code&gt;第一个参数的数据类型&lt;code&gt;id&lt;/code&gt;，&lt;code&gt;id&lt;/code&gt;是通用类型指针，能够表示任何对象。按下面路径打开&lt;code&gt;objc.h&lt;/code&gt;文件&lt;/p&gt;

&lt;p&gt;id Data Structure.png
查看到id数据结构如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/// Represents an instance of a class.
struct objc_object {
Class isa  OBJC_ISA_AVAILABILITY;
};

/// A pointer to an instance of a class.
typedef struct objc_object *id;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;id&lt;/code&gt;其实就是一个指向&lt;code&gt;objc_object&lt;/code&gt;结构体指针，它包含一个&lt;code&gt;Class isa&lt;/code&gt;成员，根据&lt;code&gt;isa&lt;/code&gt;指针就可以顺藤摸瓜找到对象所属的类。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：根据Apple的官方文档&lt;code&gt;Key-Value Observing Implementation Details&lt;/code&gt;提及，&lt;code&gt;key-value observing&lt;/code&gt;是使用&lt;code&gt;isa-swizzling&lt;/code&gt;的技术实现的，isa指针在运行时被修改，指向一个中间类而不是真正的类。所以，你不应该使用isa指针来确定类的关系，而是使用class方法来确定实例对象的类。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;class&quot;&gt;Class&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;isa&lt;/code&gt;指针的数据类型是Class，Class表示对象所属的类，按下面路径打开&lt;code&gt;objc.h&lt;/code&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Class Data Structure
/// An opaque type that represents an Objective-C class.
typedef struct objc_class *Class; 可以查看到Class其实就是一个`objc_class`结构体指针，但这个头文件找不到它的定义，需要在`runtime.h`才能找到`objc_class`结构体的定义。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按下面路径打开runtime.h文件&lt;/p&gt;

&lt;p&gt;objc_class Data Structure
查看到&lt;code&gt;objc_class&lt;/code&gt;结构体定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct objc_class {
Class isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
Class super_class                                        OBJC2_UNAVAILABLE;
const char *name                                         OBJC2_UNAVAILABLE;
long version                                             OBJC2_UNAVAILABLE;
long info                                                OBJC2_UNAVAILABLE;
long instance_size                                       OBJC2_UNAVAILABLE;
struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
#endif
} OBJC2_UNAVAILABLE;
/* Use `Class` instead of `struct objc_class *` */
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：OBJC2_UNAVAILABLE是一个Apple对Objc系统运行版本进行约束的宏定义，主要为了兼容非Objective-C 2.0的遗留版本，但我们仍能从中获取一些有用信息。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;让我们分析一些重要的成员变量表示什么意思和对应使用哪些数据结构。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;isa表示一个Class对象的Class，也就是Meta Class。在面向对象设计中，一切都是对象，Class在设计中本身也是一个对象。我们会在objc-runtime-new.h文件找到证据，发现objc_class有以下定义：&lt;/p&gt;

    &lt;p&gt;struct objc_class : objc_object {&lt;br /&gt;
  // Class ISA;&lt;br /&gt;
Class superclass;&lt;br /&gt;
cache_t cache;             // formerly cache pointer and vtable&lt;br /&gt;
class_data_bits_t bits;    // class_rw_t * plus custom rr/alloc flags&lt;br /&gt;
……&lt;br /&gt;
}`&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由此可见，结构体&lt;code&gt;objc_class&lt;/code&gt;也是继承&lt;code&gt;objc_object&lt;/code&gt;，说明Class在设计中本身也是一个对象。&lt;/p&gt;

&lt;p&gt;其实Meta Class也是一个Class，那么它也跟其他Class一样有自己的isa和super_class指针，关系如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/166109-fb22b2cd2fe17745.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Class isa and superclass relationship from Google
上图实线是super_class指针，虚线是isa指针。有几个关键点需要解释以下:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Root class (class)其实就是NSObject，NSObject是没有超类的，所以Root class(class)的superclass指向nil。&lt;/li&gt;
  &lt;li&gt;每个Class都有一个isa指针指向唯一的Meta class&lt;/li&gt;
  &lt;li&gt;Root class(meta)的superclass指向Root class(class)，也就是NSObject，形成一个回路。&lt;/li&gt;
  &lt;li&gt;每个Meta class的isa指针都指向Root class (meta)。&lt;/li&gt;
  &lt;li&gt;super_class表示实例对象对应的父类&lt;/li&gt;
  &lt;li&gt;name表示类名&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ivars表示多个成员变量，它指向objc_ivar_list结构体。在runtime.h可以看到它的定义：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  struct objc_ivar_list {  
  int ivar_count                                           		OBJC2_UNAVAILABLE;  
  #ifdef __LP64__  
  int space                                                			OBJC2_UNAVAILABLE;  
      #endif  
  /* variable length structure */    
  struct objc_ivar ivar_list[1]  
  OBJC2_UNAVAILABLE;  
  } `objc_ivar_list`其实就是一个链表，存储多个`objc_ivar`，而`objc_ivar`结构体存储类的单个成员变量信息。
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;methodLists表示方法列表，它指向objc_method_list结构体的二级指针，可以动态修改*methodLists的值来添加成员方法，也是Category实现原理，同样也解释Category不能添加实例变量的原因。在runtime.h可以看到它的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	struct objc_method_list {
  				struct objc_method_list *obsolete                        				OBJC2_UNAVAILABLE;
&lt;/code&gt;&lt;/pre&gt;

 				 int method_count                                         				OBJC2_UNAVAILABLE;
&lt;pre&gt;&lt;code&gt;			#ifdef __LP64__
  				int space                                                				OBJC2_UNAVAILABLE;
			#endif   /* variable length structure */   struct objc_method method_list[1]                        OBJC2_UNAVAILABLE; }` 同理，objc_method_list也是一个链表，存储多个objc_method，而objc_method结构体存储类的某个方法的信息。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;cache用来缓存经常访问的方法，它指向objc_cache结构体，后面会重点讲到。&lt;/p&gt;

&lt;p&gt;protocols表示类遵循哪些协议
Method
Method表示类中的某个方法，在runtime.h文件中找到它的定义：&lt;/p&gt;

&lt;p&gt;/// An opaque type that represents a method in a class definition.
typedef struct objc_method *Method;&lt;/p&gt;

&lt;p&gt;struct objc_method {
    SEL method_name                                          OBJC2_UNAVAILABLE;
    char *method_types                                       OBJC2_UNAVAILABLE;
    IMP method_imp                                           OBJC2_UNAVAILABLE;
}
其实Method就是一个指向objc_method结构体指针，它存储了方法名(method_name)、方法类型(method_types)和方法实现(method_imp)等信息。而method_imp的数据类型是IMP，它是一个函数指针，后面会重点提及。&lt;/p&gt;

&lt;p&gt;Ivar
Ivar表示类中的实例变量，在runtime.h文件中找到它的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/// An opaque type that represents an instance variable.
typedef struct objc_ivar *Ivar;

struct objc_ivar {
char *ivar_name                                          OBJC2_UNAVAILABLE;
char *ivar_type                                          OBJC2_UNAVAILABLE;
int ivar_offset                                          OBJC2_UNAVAILABLE;
#ifdef __LP64__
int space                                                OBJC2_UNAVAILABLE;
#endif
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Ivar&lt;/code&gt;其实就是一个指向&lt;code&gt;objc_ivar&lt;/code&gt;结构体指针，它包含了变量名&lt;code&gt;(ivar_name)&lt;/code&gt;、变量类型(ivar_type)等信息。&lt;/p&gt;

&lt;p&gt;IMP
在上面讲Method时就说过，IMP本质上就是一个函数指针，指向方法的实现，在objc.h找到它的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/// A pointer to the function of a method implementation. 
#if !OBJC_OLD_DISPATCH_PROTOTYPES
typedef void (*IMP)(void /* id, SEL, ... */ ); 
#else
typedef id (*IMP)(id, SEL, ...); 
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当你向某个对象发送一条信息，可以由这个函数指针来指定方法的实现，它最终就会执行那段代码，这样可以绕开消息传递阶段而去执行另一个方法实现。&lt;/p&gt;

&lt;p&gt;Cache
顾名思义，Cache主要用来缓存，那它缓存什么呢？我们先在runtime.h文件看看它的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;typedef struct objc_cache *Cache                             OBJC2_UNAVAILABLE;

struct objc_cache {
unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;
unsigned int occupied                                    OBJC2_UNAVAILABLE;
Method buckets[1]                                        OBJC2_UNAVAILABLE;
}; Cache其实就是一个存储Method的链表，主要是为了优化方法调用的性能。当对象receiver调用方法message时，首先根据对象receiver的isa指针查找到它对应的类，然后在类的methodLists中搜索方法，如果没有找到，就使用super_class指针到父类中的methodLists查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用Cache来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;消息发送
前面从objc_msgSend作为入口，逐步深入分析Runtime的数据结构，了解每个数据结构的作用和它们之间关系后，我们正式转入消息发送这个正题。&lt;/p&gt;

&lt;p&gt;objc_msgSend函数
在前面已经提过，当某个对象使用语法[receiver message]来调用某个方法时，其实[receiver message]被编译器转化为:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;id objc_msgSend ( id self, SEL op, ... );&lt;/code&gt;
现在让我们看一下objc_msgSend它具体是如何发送消息:&lt;/p&gt;

&lt;p&gt;首先根据receiver对象的isa指针获取它对应的class
优先在class的cache查找message方法，如果找不到，再到methodLists查找
如果没有在class找到，再到super_class查找
一旦找到message这个方法，就执行它实现的IMP。&lt;/p&gt;

&lt;p&gt;Objc Message.gif
self与super
为了让大家更好地理解self和super，借用sunnyxx博客的ios程序员6级考试一道题目：下面的代码分别输出什么？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@implementation Son : Father
- (id)init
{
self = [super init];
if (self)
{
    NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));
    NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));
}
return self;
}
@end self表示当前这个类的对象，而super是一个编译器标示符，和self指向同一个消息接受者。在本例中，无论是[self class]还是[super class]，接受消息者都是Son对象，但super与self不同的是，self调用class方法时，是在子类Son中查找方法，而super调用class方法时，是在父类Father中查找方法。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当调用[self class]方法时，会转化为objc_msgSend函数，这个函数定义如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;id objc_msgSend(id self, SEL op, ...)&lt;/code&gt;
这时会从当前Son类的方法列表中查找，如果没有，就到Father类查找，还是没有，最后在NSObject类查找到。我们可以从NSObject.mm文件中看到- (Class)class的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (Class)class {
return object_getClass(self);
} 所以`NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));`会输出Son。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当调用[super class]方法时，会转化为objc_msgSendSuper，这个函数定义如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;id objc_msgSendSuper(struct objc_super *super, SEL op, ...)&lt;/code&gt;
objc_msgSendSuper函数第一个参数super的数据类型是一个指向objc_super的结构体，从message.h文件中查看它的定义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/// Specifies the superclass of an instance. 
struct objc_super {
/// Specifies an instance of a class.
__unsafe_unretained id receiver;

/// Specifies the particular superclass of the instance to message. 
#if !defined(__cplusplus)  &amp;amp;&amp;amp;  !__OBJC2__
/* For compatibility with old objc-runtime.h header */
__unsafe_unretained Class class;
#else
__unsafe_unretained Class super_class;
#endif
/* super_class is the first class to search */
};
#endif 结构体包含两个成员，第一个是receiver，表示某个类的实例。第二个是super_class表示当前类的父类。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这时首先会构造出objc_super结构体，这个结构体第一个成员是self，第二个成员是(id)class_getSuperclass(objc_getClass(“Son”))，实际上该函数会输出Father。然后在Father类查找class方法，查找不到，最后在NSObject查到。此时，内部使用objc_msgSend(objc_super-&amp;gt;receiver, @selector(class))去调用，与[self class]调用相同，所以结果还是Son。&lt;/p&gt;

&lt;p&gt;隐藏参数self和_cmd
当[receiver message]调用方法时，系统会在运行时偷偷地动态传入两个隐藏参数self和_cmd，之所以称它们为隐藏参数，是因为在源代码中没有声明和定义这两个参数。至于对于self的描述，上面已经解释非常清楚了，下面我们重点讲解_cmd。&lt;/p&gt;

&lt;p&gt;_cmd表示当前调用方法，其实它就是一个方法选择器SEL。一般用于判断方法名或在Associated Objects中唯一标识键名，后面在Associated Objects会讲到。&lt;/p&gt;

&lt;p&gt;方法解析与消息转发
[receiver message]调用方法时，如果在message方法在receiver对象的类继承体系中没有找到方法，那怎么办？一般情况下，程序在运行时就会Crash掉，抛出 unrecognized selector sent to …类似这样的异常信息。但在抛出异常之前，还有三次机会按以下顺序让你拯救程序。&lt;/p&gt;

&lt;p&gt;Method Resolution
Fast Forwarding
Normal Forwarding&lt;/p&gt;

&lt;p&gt;Message Forward from Google
Method Resolution
首先Objective-C在运行时调用+ resolveInstanceMethod:或+ resolveClassMethod:方法，让你添加方法的实现。如果你添加方法并返回YES，那系统在运行时就会重新启动一次消息发送的过程。&lt;/p&gt;

&lt;p&gt;举一个简单例子，定义一个类Message，它主要定义一个方法sendMessage，下面就是它的设计与实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface Message : NSObject

- (void)sendMessage:(NSString *)word;

@end
@implementation Message

- (void)sendMessage:(NSString *)word
{
	NSLog(@&quot;normal way : send message = %@&quot;, word);
}

@end 如果我在viewDidLoad方法中创建Message对象并调用sendMessage方法：

- (void)viewDidLoad {
[super viewDidLoad];

Message *message = [Message new];
[message sendMessage:@&quot;Sam Lau&quot;];
} 控制台会打印以下信息:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;normal way : send message = Sam Lau
但现在我将原来sendMessage方法实现给注释掉，覆盖resolveInstanceMethod方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#pragma mark - Method Resolution

/// override resolveInstanceMethod or resolveClassMethod for changing sendMessage method implementation
+ (BOOL)resolveInstanceMethod:(SEL)sel
{
if (sel == @selector(sendMessage:)) {
    class_addMethod([self class], sel, imp_implementationWithBlock(^(id self, NSString *word) {
        NSLog(@&quot;method resolution way : send message = %@&quot;, word);
    }), &quot;v@*&quot;);
}

return YES;
} 控制台就会打印以下信息：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;method resolution way : send message = Sam Lau
注意到上面代码有这样一个字符串”v@*，它表示方法的参数和返回值，详情请参考Type Encodings&lt;/p&gt;

&lt;p&gt;如果resolveInstanceMethod方法返回NO，运行时就跳转到下一步：消息转发(Message Forwarding)&lt;/p&gt;

&lt;p&gt;Fast Forwarding
如果目标对象实现- forwardingTargetForSelector:方法，系统就会在运行时调用这个方法，只要这个方法返回的不是nil或self，也会重启消息发送的过程，把这消息转发给其他对象来处理。否则，就会继续Normal Fowarding。&lt;/p&gt;

&lt;p&gt;继续上面Message类的例子，将sendMessage和resolveInstanceMethod方法注释掉，然后添加forwardingTargetForSelector方法的实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#pragma mark - Fast Forwarding
- (id)forwardingTargetForSelector:(SEL)aSelector
{
if (aSelector == @selector(sendMessage:)) {
    return [MessageForwarding new];
}

return nil;
} 此时还缺一个转发消息的类MessageForwarding，这个类的设计与实现如下：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;@interface MessageForwarding : NSObject&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(void)sendMessage:(NSString *)word;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;@end
@implementation MessageForwarding&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;(void)sendMessage:(NSString *)word
{
  NSLog(@”fast forwarding way : send message = %@”, word);
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;@end
此时，控制台会打印以下信息：&lt;/p&gt;

&lt;p&gt;fast forwarding way : send message = Sam Lau
这里叫Fast，是因为这一步不会创建NSInvocation对象，但Normal Forwarding会创建它，所以相对于更快点。&lt;/p&gt;

&lt;p&gt;Normal Forwarding
如果没有使用Fast Forwarding来消息转发，最后只有使用Normal Forwarding来进行消息转发。它首先调用methodSignatureForSelector:方法来获取函数的参数和返回值，如果返回为nil，程序会Crash掉，并抛出unrecognized selector sent to instance异常信息。如果返回一个函数签名，系统就会创建一个NSInvocation对象并调用-forwardInvocation:方法。&lt;/p&gt;

&lt;p&gt;继续前面的例子，将forwardingTargetForSelector方法注释掉，添加methodSignatureForSelector和forwardInvocation方法的实现：&lt;/p&gt;

&lt;h1 id=&quot;pragma-mark---normal-forwarding&quot;&gt;pragma mark - Normal Forwarding&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;(NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector
{
  NSMethodSignature *methodSignature = [super methodSignatureForSelector:aSelector];&lt;/p&gt;

    &lt;p&gt;if (!methodSignature) {
      methodSignature = [NSMethodSignature signatureWithObjCTypes:”v@:*”];
  }&lt;/p&gt;

    &lt;p&gt;return methodSignature;
}&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(void)forwardInvocation:(NSInvocation *)anInvocation
{
  MessageForwarding *messageForwarding = [MessageForwarding new];&lt;/p&gt;

    &lt;p&gt;if ([messageForwarding respondsToSelector:anInvocation.selector]) {
      [anInvocation invokeWithTarget:messageForwarding];
  }
}
关于这个例子的示例代码请到github下载。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;三种方法的选择
Runtime提供三种方式来将原来的方法实现代替掉，那该怎样选择它们呢？&lt;/p&gt;

&lt;p&gt;Method Resolution：由于Method Resolution不能像消息转发那样可以交给其他对象来处理，所以只适用于在原来的类中代替掉。
Fast Forwarding：它可以将消息处理转发给其他对象，使用范围更广，不只是限于原来的对象。
Normal Forwarding：它跟Fast Forwarding一样可以消息转发，但它能通过NSInvocation对象获取更多消息发送的信息，例如：target、selector、arguments和返回值等信息。
Associated Objects
Categories can be used to declare either instance methods or class methods but are not usually suitable for declaring additional properties. It’s valid syntax to include a property declaration in a category interface, but it’s not possible to declare an additional instance variable in a category. This means the compiler won’t synthesize any instance variable, nor will it synthesize any property accessor methods. You can write your own accessor methods in the category implementation, but you won’t be able to keep track of a value for that property unless it’s already stored by the original class. (Programming with Objective-C)
当想使用Category对已存在的类进行扩展时，一般只能添加实例方法或类方法，而不适合添加额外的属性。虽然可以在Category头文件中声明property属性，但在实现文件中编译器是无法synthesize任何实例变量和属性访问方法。这时需要自定义属性访问方法并且使用Associated Objects来给已存在的类Category添加自定义的属性。Associated Objects提供三个API来向对象添加、获取和删除关联值：&lt;/p&gt;

&lt;p&gt;void objc_setAssociatedObject (id object, const void *key, id value, objc_AssociationPolicy policy )
id objc_getAssociatedObject (id object, const void *key )
void objc_removeAssociatedObjects (id object )
其中objc_AssociationPolicy是个枚举类型，它可以指定Objc内存管理的引用计数机制。&lt;/p&gt;

&lt;p&gt;typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {
    OBJC_ASSOCIATION_ASSIGN = 0,           /&lt;strong&gt;&amp;lt; Specifies a weak reference to the associated object. */
    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /&lt;/strong&gt;&amp;lt; Specifies a strong reference to the associated object. 
                                            *   The association is not made atomically. */
    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /&lt;strong&gt;&amp;lt; Specifies that the associated object is copied. 
                                            *   The association is not made atomically. */
    OBJC_ASSOCIATION_RETAIN = 01401,       /&lt;/strong&gt;&amp;lt; Specifies a strong reference to the associated object.
                                            *   The association is made atomically. */
    OBJC_ASSOCIATION_COPY = 01403          /**&amp;lt; Specifies that the associated object is copied.
                                            *   The association is made atomically. */
};
下面有个关于NSObject+AssociatedObject Category添加属性associatedObject的示例代码:&lt;/p&gt;

&lt;p&gt;NSObject+AssociatedObject.h
@interface NSObject (AssociatedObject)&lt;/p&gt;

&lt;p&gt;@property (strong, nonatomic) id associatedObject;&lt;/p&gt;

&lt;p&gt;@end
NSObject+AssociatedObject.m
@implementation NSObject (AssociatedObject)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;(void)setAssociatedObject:(id)associatedObject
{
  objc_setAssociatedObject(self, @selector(associatedObject), associatedObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
}&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;(id)associatedObject
{
  return objc_getAssociatedObject(self, _cmd);
}&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;@end
Associated Objects的key要求是唯一并且是常量，而SEL是满足这个要求的，所以上面的采用隐藏参数_cmd作为key。&lt;/p&gt;

&lt;h2 id=&quot;method-swizzling&quot;&gt;Method Swizzling&lt;/h2&gt;
&lt;p&gt;Method Swizzling就是在运行时将一个方法的实现代替为另一个方法的实现。如果能够利用好这个技巧，可以写出简洁、有效且维护性更好的代码。可以参考两篇关于Method Swizzling技巧的文章：&lt;/p&gt;

&lt;p&gt;nshipster Method Swizzling
Method Swizzling 和 AOP 实践
Aspect-Oriented Programming(AOP)
类似记录日志、身份验证、缓存等事务非常琐碎，与业务逻辑无关，很多地方都有，又很难抽象出一个模块，这种程序设计问题，业界给它们起了一个名字叫横向关注点(Cross-cutting concern)，AOP作用就是分离横向关注点(Cross-cutting concern)来提高模块复用性，它可以在既有的代码添加一些额外的行为(记录日志、身份验证、缓存)而无需修改代码。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;危险性&lt;/h2&gt;
&lt;p&gt;Method Swizzling就像一把瑞士小刀，如果使用得当，它会有效地解决问题。但使用不当，将带来很多麻烦。在stackoverflow上有人已经提出这样一个问题：What are the Dangers of Method Swizzling in Objective C?，它的危险性主要体现以下几个方面：&lt;/p&gt;

&lt;p&gt;Method swizzling is not atomic
Changes behavior of un-owned code
Possible naming conflicts
Swizzling changes the method’s arguments
The order of swizzles matters
Difficult to understand (looks recursive)
Difficult to debug
#总结
虽然在平时项目不是经常用到Objective-C的Runtime特性，但当你阅读一些iOS开源项目时，你就会发现很多时候都会用到。所以深入理解Objective-C的Runtime数据结构、消息转发机制有助于你更容易地阅读和学习开源项目。&lt;/p&gt;
</description>
				<pubDate>Fri, 07 Aug 2015 00:00:00 +0800</pubDate>
				<link>/2015/08/07/0runtime.html</link>
				<guid isPermaLink="true">/2015/08/07/0runtime.html</guid>
			</item>
		
			<item>
				<title>学习git</title>
				<description>&lt;h2 id=&quot;git&quot;&gt;Git基本工作流程&lt;/h2&gt;
&lt;p&gt;在git版本控制的目录下修改某个文件
使用git add命令对修改后的文件快照，保存到暂存区域
使用git commit命令提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中
##Git基本技巧
* 自动补全
* Git 命令别名
关于具体如何使用自动补全和命名别名技巧，请查看Pro git的技巧和窍门&lt;/p&gt;

&lt;h1 id=&quot;git-1&quot;&gt;Git版本控制&lt;/h1&gt;
&lt;p&gt;git init
git clone
git config
#保存修改
git add
git commit
##查看仓库
git status
git log –oneline
##撤销修改
###查看之前的commit
git checkout &lt;commit&gt; &lt;file&gt;
git checkout &lt;commit&gt;
git checkout &lt;branch&gt;
###撤销公共修改
git revert &lt;commit&gt;
###撤销本地修改
git reset
git clean
##重写Git历史记录
git commit --amend
git rebase
git reflog
##Git协作开发
###分支
git branch
git checkout
git merge
##仓库同步
git remote
git fetch
git pull
git push
##Git工作流
由于git拥有强大的分支特性，它的工作流比较灵活而缺乏约束，于是参考Atlassian Git Tutorial的Comparing Workflows章节提供四种Git工作流：&lt;/commit&gt;&lt;/branch&gt;&lt;/commit&gt;&lt;/file&gt;&lt;/commit&gt;&lt;/p&gt;

&lt;p&gt;Centralized Workflow
Feature Branch Workflow
Gitflow Workflow
Forking Workflow
以上工作流只是参考指南，而不是具体规则。你可以根据自己实际情况来选择适合自己的工作流或微调来满足自己的需要。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git log --pretty=oneline&lt;/code&gt;
输出简化版的日志信息&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;4a0ef4fb687c2b4d1cdb2ca6b0dac325808371ad add read.txt
一大串的数字是哈西码&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交3628164…882e1e0（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;git reset --hard 88d3a3e9d397023621911816daa4b27b31e260c2&lt;/code&gt;
回到某个版本上去&lt;/p&gt;

&lt;p&gt;想后悔了怎么办&lt;/p&gt;

&lt;p&gt;现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？&lt;/p&gt;

&lt;p&gt;在Git中，总是有后悔药可以吃的。当你用$ git reset –hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令：&lt;/p&gt;

&lt;p&gt;现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。&lt;/p&gt;

&lt;p&gt;现在，你又理解了Git是如何跟踪修改的，每次修改，如果不add到暂存区，那就不会加入到commit中。&lt;/p&gt;

&lt;p&gt;git checkout – file命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;删除文件&lt;/h2&gt;
&lt;p&gt;$ rm test.txt
$ git rm test.txt&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;rm &#39;test.txt&#39;
$ git commit -m &quot;remove test.txt&quot;
[master d17efd8] remove test.txt
1 file changed, 1 deletion(-)
delete mode 100644 test.txt
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;上传代码&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;git remote add origin https://github.com/kekeYe/testgit.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。&lt;/p&gt;

&lt;p&gt;由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。&lt;/p&gt;

&lt;p&gt;从现在起，只要本地作了提交，就可以通过命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git；&lt;/p&gt;

&lt;p&gt;关联后，使用命令git push -u origin master第一次推送master分支的所有内容；&lt;/p&gt;

&lt;p&gt;此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改；&lt;/p&gt;

&lt;p&gt;分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;创建分支&lt;/h2&gt;
&lt;p&gt;首先，我们创建dev分支，然后切换到dev分支：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout -b dev
Switched to a new branch &#39;dev&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;git checkout命令加上-b参数表示创建并切换，相当于以下两条命令：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch dev
$ git checkout dev
Switched to branch &#39;dev&#39;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;切换主分支&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git checkout master
Switched to branch &#39;master&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;section-3&quot;&gt;合并分支&lt;/h5&gt;
&lt;p&gt;现在，我们把dev分支的工作成果合并到master分支上：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ git merge dev
Updating d17efd8..fec145a
Fast-forward
 readme.txt |    1 +
 1 file changed, 1 insertion(+)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。&lt;/p&gt;

&lt;p&gt;注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。&lt;/p&gt;

&lt;p&gt;当然，也不是每次合并都能Fast-forward，我们后面会将其他方式的合并。&lt;/p&gt;

&lt;p&gt;合并完成后，就可以放心地删除dev分支了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch -d dev
Deleted branch dev (was fec145a). 删除后，查看branch，就只剩下master分支了：

$ git branch
* master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git鼓励大量使用分支：&lt;/p&gt;

&lt;p&gt;查看分支：git branch&lt;/p&gt;

&lt;p&gt;创建分支：git branch &lt;name&gt;&lt;/name&gt;&lt;/p&gt;

&lt;p&gt;切换分支：git checkout &lt;name&gt;&lt;/name&gt;&lt;/p&gt;

&lt;p&gt;创建+切换分支：git checkout -b &lt;name&gt;&lt;/name&gt;&lt;/p&gt;

&lt;p&gt;合并某分支到当前分支：git merge &lt;name&gt;&lt;/name&gt;&lt;/p&gt;

&lt;p&gt;删除分支：git branch -d &lt;name&gt;	
##解决冲突
切换分支修改内容提交
然后切换回主分支  故意冲突
最后合并报错&lt;/name&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git merge feature1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解决冲突后 就可以上传了&lt;/p&gt;

&lt;p&gt;当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。&lt;/p&gt;

&lt;p&gt;用git log –graph命令可以看到分支合并图。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;合并&lt;/h2&gt;

&lt;p&gt;Git分支十分强大，在团队开发中应该充分应用。&lt;/p&gt;

&lt;p&gt;合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git merge --no-ff -m &quot;merge with no-ff&quot; dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;bug&quot;&gt;解决突发状况 开发到一半去改bug&lt;/h2&gt;
&lt;p&gt;修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；&lt;/p&gt;

&lt;p&gt;当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。&lt;/p&gt;

&lt;p&gt;工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：&lt;/p&gt;

&lt;p&gt;一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；&lt;/p&gt;

&lt;p&gt;另一种方式是用git stash pop，恢复的同时把stash内容也删了：&lt;/p&gt;

&lt;p&gt;开发在dev分支上进行 
改bug 也要在分支上 进行&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;强行删除&lt;/h2&gt;
&lt;p&gt;虽然白干了，但是这个分支还是必须就地销毁：&lt;/p&gt;

&lt;p&gt;$ git branch -d feature-vulcan
error: The branch ‘feature-vulcan’ is not fully merged.
If you are sure you want to delete it, run ‘git branch -D feature-vulcan’.
销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用命令git branch -D feature-vulcan。&lt;/p&gt;

&lt;p&gt;现在我们强行删除：&lt;/p&gt;

&lt;p&gt;$ git branch -D feature-vulcan
Deleted branch feature-vulcan (was 756d4af).&lt;/p&gt;

&lt;p&gt;推送分支&lt;/p&gt;

&lt;p&gt;推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git push origin master 如果要推送其他分支，比如dev，就改成：

$ git push origin dev
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-6&quot;&gt;推送分支&lt;/h2&gt;
&lt;p&gt;但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？&lt;/p&gt;

&lt;p&gt;master分支是主分支，因此要时刻与远程同步；&lt;/p&gt;

&lt;p&gt;dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；&lt;/p&gt;

&lt;p&gt;bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；&lt;/p&gt;

&lt;p&gt;feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。&lt;/p&gt;

&lt;p&gt;总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！&lt;/p&gt;

&lt;h2 id=&quot;git-&quot;&gt;给git 命令改名字&lt;/h2&gt;
&lt;p&gt;有没有经常敲错命令？比如git status？status这个单词真心不好记。&lt;/p&gt;

&lt;p&gt;如果敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。&lt;/p&gt;

&lt;p&gt;我们只需要敲一行命令，告诉Git，以后st就表示status：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git config --global alias.st status
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&quot;log&quot;&gt;强大log&lt;/h5&gt;
&lt;blockquote&gt;
  &lt;pre&gt;&lt;code&gt;log --color --graph --pretty=format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&amp;lt;%an&amp;gt;%Creset&#39; --abbrev-commit
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

</description>
				<pubDate>Mon, 13 Jul 2015 00:00:00 +0800</pubDate>
				<link>/2015/07/13/2%E5%AD%A6%E4%B9%A0git.html</link>
				<guid isPermaLink="true">/2015/07/13/2%E5%AD%A6%E4%B9%A0git.html</guid>
			</item>
		
			<item>
				<title>iOS App性能优化</title>
				<description>&lt;h2 id=&quot;ios-app&quot;&gt;iOS App的性能关注点&lt;/h2&gt;
&lt;p&gt;虽然iPhone的机能越来越好，但是app的功能也越来越复杂，性能从来都是移动开发的核心关注点之一。我们说一个app性能好，不是简单指感觉运行速度快，而应该是指应用启动快速、UI反馈响应及时、列表滚动操作流畅、内存使用合理，当然更不能随随便便Crash啦。工程师开发应用时除了在设计上要避免性能“坑”的出现，在实际遇到“坑”时也要能很快定位原因所在。定位性能问题原因当然不能靠猜，合理的方法是使用工具测量评估出投资回报最高的问题点，然后再加以优化。&lt;/p&gt;

&lt;p&gt;本文会从以下几点介绍如何分析和优化iOS app的性能：启动时间、用户响应、内存、图形动画、文件和网络I/O。其中会用到Apple出品的性能分析神器“Instruments”。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;启动时间&lt;/h2&gt;
&lt;p&gt;应用启动时间长短对用户第一次体验至关重要，同时系统对应用的启动、恢复等状态的运行时间也有严格的要求，在应用超时的情况下系统会直接关闭应用。以下是几个常见场景下系统对app运行时间的要求：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Launch 20秒&lt;/li&gt;
  &lt;li&gt;Resume 10秒&lt;/li&gt;
  &lt;li&gt;Suspend 10秒&lt;/li&gt;
  &lt;li&gt;Quit 6秒&lt;/li&gt;
  &lt;li&gt;Background Task 10分钟&lt;/li&gt;
  &lt;li&gt;要获取准确的app启动所需时间，最简单的方法时首先在main.c中添加如下代码：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt; CFAbsoluteTime StartTime;  
 int main(int argc, char **argv) {  
 StartTime = CFAbsoluteTimeGetCurrent(); &lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后在AppDelegate的回调方法&lt;code&gt;application:didFinishLaunchingWithOptions&lt;/code&gt;中添加：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dispatch_async(dispatch_get_main_queue(), ^{
NSLog(@”Lauched in %f seconds.”,  (CFAbsoluteTimeGetCurrent() – StartTime));
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能你会觉得为什么这样可拿到系统启动的时间，因为这个dispatch_async中提交的工作会在app主线程启动后的下一个run lopp中运行，此时app已经完成了载入并且将要显示第一帧画面，也就是系统会运行到-[UIApplication _reportAppLaunchFinished]之前。下图是用Instruments工具Time Profiler跑的调用栈，Instruments的使用方法建议看WWDC中与performance相关的session录像，文字写起来太单薄不够直观哈。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015-7_13_app/1.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从图中我们可以看到在系统调用&lt;code&gt;[UIApplication _reportAppLaunchFinished]&lt;/code&gt;之前完成了系统回调&lt;code&gt;application:didFinishLaunchingWithOptions。&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;App的启动会包括以下几个部分（来自WWDC 2012 Session 235）:&lt;/p&gt;

&lt;p&gt;1）链接和载入：可以在Time Profile中显示dyld载入库函数，库会被映射到地址空间，同时完成绑定以及静态初始化。&lt;/p&gt;

&lt;p&gt;2）UIKit初始化：如果应用的Root View Controller是由XIB实现的，也会在启动时被初始化。&lt;/p&gt;

&lt;p&gt;3）应用回调：调用UIApplicationDeleagte的回调：&lt;code&gt;application:didFinishLaunchingWithOptions&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;4）第一次Core Animation调用：在启动后的方法&lt;code&gt;-[UIApplication _resportAppLaunchFinished]&lt;/code&gt;中调用&lt;code&gt;CA::Transaction::commit&lt;/code&gt;实现第一帧画面的绘制。&lt;/p&gt;

&lt;p&gt;如果你的程序启动很慢，能 做的首先是将与显示第一屏画面无关的操作放到之后执行；如果是用XIB文件load第一屏，XIB文件中的View层也要如果扁平，不要有太多图层。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;用户响应&lt;/h2&gt;
&lt;p&gt;如何能够让用户觉得你的app响应迅速呢？当然是app用户所触发的操作都能得到立刻响应，即用户事件(User Event)能够被主线程的run loop及时处理。什么是run loop？可以想象成一个处理事件的select多路复用。主线程中的run loop当然主要是为了处理用户产生的事件啦，例如点击、滚动等。以后我们会详细聊聊run loop这个让人迷惑的东东。&lt;/p&gt;

&lt;p&gt;要让主线程的run loop更好的响应用户事件，工程师应该尽量减少主线程干重活的时间，尤其是读文件啊，网络操作啊，大量运算啊这类重活，如果是阻塞操作，那就更是大忌了。我们可以用多线程(NSThread、NSOperationQueue, GCD，下一篇Blog就会聊到这多线程)将重活移出主线程，这属于显式并发。还有种隐式并发，例如view和layer的动画、layer的绘制以及PNG图片的解码都是在另一个子线程中执行的。除了使用多线程技术减轻主线程的负担外，减少主线程中阻塞也是提升用户体验的一个方法。使用Instruments中Time Profiler工具中的”Recod thread waiting”选项可以统计出app运行时各个线程中的阻塞系统调用情况，例如文件读写read/write，网络读写send/recv，加锁psynchmutexwait等。Instruments中的System Trace工具则能够记录所有的底层系统调用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015-7_13_app/2.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;内存&lt;/h2&gt;
&lt;p&gt;内存问题从来都是iOS app的老大难问题，搞不好程序就爆了。由于iOS系统没有Swap文件(知道为啥不？留给悬念)，在内存不足时会将只读数据(例如code page)从内存中移出，需要的时候再从disk上读如内存；可读写数据不会被系统从内存中移出，然而如果占用的内存达到一个阈值，系统会发出相应的通知和回调让应用release对象以回收内存，如果仍然不能减少内存使用量，系统会直接关闭应用。尤其是iOS 5.0之后，如果你的app收到了memory warning，那么脑袋也是和其他app一样放在了案板上，随时有可能被kill掉，并不是说一定会先Kill掉在后台的app。&lt;/p&gt;

&lt;p&gt;App使用的内存除了我们在堆上分配的内存外（+[NSobject alloc]/malloc），还会有更多使用内存的地方，比如代码和全局数据（TEXT和DATA），线程栈，图片，view 的layer backing store等等。因此处理内存问题，绝不仅仅是我们开发app时尽量少申请内存那么简单。&lt;/p&gt;

&lt;p&gt;现在有了超炫的ARC，内存问题相对少了很多，开发效率也得到了提高。但是很多公司的项目仍然由于历史原因采用了手动管理内存，该做的活还是少不了。Xcode自带的静态分析功能可以帮你提前发现一些问题，然而有些内存问题是无法用静态分析来发现的，例如我们不断使用内存没有及时释放的问题，就无法使用静态分析器分析出来。此时可以使用Instruments的Allocations和Leaks工具来检查运行时的的内存使用以及泄露问题。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015-7_13_app/3.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Allocations工具可以很直观的反应app的内存使用情况，还有个很赞“Mark Heap”功能，在上图左边下半部分中的Heapshot Analysis中。例如你在进入一个页面前点击一下“Mark Heap”，然后再退回上一页面点击一下“Mark Heap”，如果你在进出这个页面里所申请的内存都得到了合理的释放，那么堆的内存增长量就应该降至0（见上图右下部分）。&lt;/p&gt;

&lt;p&gt;另一种严重的内存使用问题是引用了已经释放的内存，直接导致应用崩溃，而Allocation有一个选项Enable NSZombie detection能够在应用使用已经释放的内存时标注出来，同时显示错误发生的调用栈信息。这为解决问题提供了最直接的帮助，当然缺点是必须能够重现EXECBADACCESS错误。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015-7_13_app/4.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;工具Leaks可以在应用运行时直接标示出存在内存泄露的代码，如果发生了内存泄露，可以从泄露详细信息中查看泄露的具体对象以及方法调用栈，大部分问题还是很好解决的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015-7_13_app/5.png?raw=true&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;图形和动画&lt;/h2&gt;
&lt;p&gt;图形性能对用户体验有直接的影响，Instruments中的Core Animation工具用于测量物理机上的图形性能，通过视图的刷新频率大小来判断应用的图形性能。例如一个复杂的列表滚动时它的刷新率应该努力趋近于60fps才能让用户觉得够流畅，从这个数字也可以算出run loop最长的响应时间应该是16毫秒。&lt;/p&gt;

&lt;p&gt;启动Instruments的Core Animation工具后可以发现左下部分有一堆选项，我们来逐个介绍：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015-7_13_app/6.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1) Color Blended Layers&lt;/p&gt;

&lt;p&gt;Instruments可以在物理机上显示出被混合的图层Blended Layer(用红色标注)，Blended Layer是因为这些Layer是透明的(Transparent)，系统在渲染这些view时需要将该view和下层view混合(Blend)后才能计算出该像素点的实际颜色，如果这种blended layer很多，那么在滚动列表时就甭想有流畅的效果。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015-7_13_app/7.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;解决blended layer问题也很简单，检查红色区域view的opaque属性，记得设置成YES；检查backgroundColor属性是不是[UIColor clearColor]，要知道背景颜色为clear color那可是图形性能的大敌，基本意味着blended layer是跑不了的了，为什么？自己思考一下:)&lt;/p&gt;

&lt;p&gt;2) Color Hits Green and Misses Red&lt;/p&gt;

&lt;p&gt;很多视图Layer由于Shadow、Mask和Gradient等原因渲染很高，因此UIKit提供了API用于缓存这些Layer：[layer setShouldRasterize:YES]，系统会将这些Layer缓存成Bitmap位图供渲染使用，如果失效时便丢弃这些Bitmap重新生成。图层Rasterization栅格化好处是对刷新率影响较小，坏处是删格化处理后的Bitmap缓存需要占用内存，而且当图层需要缩放时，要对删格化后的Bitmap做额外计算。&lt;/p&gt;

&lt;p&gt;使用这个选项后时，如果Rasterized的Layer失效，便会标注为红色，如果有效标注为绿色。当测试的应用频繁闪现出红色标注图层时，表明对图层做的Rasterization作用不大。&lt;/p&gt;

&lt;p&gt;3) Color Misaligned Images&lt;/p&gt;

&lt;p&gt;Misaligned Image表示要绘制的点无法直接映射到频幕上的像素点，此时系统需要对相邻的像素点做anti-aliasing反锯齿计算，增加了图形负担，通常这种问题出在对某些View的Frame重新计算和设置时产生的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015-7_13_app/8.png?raw=true&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图中被标注为黄色的图层，这是由于图层显示的是被缩放后的图片，如果这些图片是通过网络下载的，可以通过程序更新为确定的绘制大小来解决。还有些系统Navigation Bar和Tool Bar的背景图片使用的是拉伸(Streched)图片，也会被表示为黄色，这是属于正常情况，通常无需修改。这种问题一般对性能影响不大，而是可能会在边缘处虚化。&lt;/p&gt;

&lt;p&gt;(4) Color Offscreen-Rendered Yellow&lt;/p&gt;

&lt;p&gt;Offscreen-Rendering离屏渲染意思是iOS要显示一个视图时，需要先在后台用CPU计算出视图的Bitmap，再交给GPU做Onscreen-Rendering显示在屏幕上，因为显示一个视图需要两次计算，所以这种Offscreen-Rendering会导致app的图形性能下降。&lt;/p&gt;

&lt;p&gt;大部分Offscreen-Rendering都是和视图Layer的Shadow和Mask相关，下列情况会导致视图的Offscreen-Rendering：&lt;/p&gt;

&lt;p&gt;使用Core Graphics (CG开头的类)。&lt;/p&gt;

&lt;p&gt;使用drawRect()方法，即使为空。&lt;/p&gt;

&lt;p&gt;将CALayer的属性shouldRasterize设置为YES。&lt;/p&gt;

&lt;p&gt;使用了CALayer的setMasksToBounds(masks)和setShadow*(shadow)方法。&lt;/p&gt;

&lt;p&gt;在屏幕上直接显示文字，包括Core Text。&lt;/p&gt;

&lt;p&gt;设置UIViewGroupOpacity。&lt;/p&gt;

&lt;p&gt;这篇博文Designing for iOS: Graphics &amp;amp; Performance对offsreen以及图形性能有个很棒的介绍，&lt;/p&gt;

&lt;p&gt;(5) Color Copied Images&lt;/p&gt;

&lt;p&gt;Copied Image选项可以标注应用绘制时被Core Animation复制的图片，标注成蓝绿色。虽然我在运行时遇到过，不过个人感觉对图形性能影响不大。&lt;/p&gt;

&lt;p&gt;(6) Color Immediately，Flash Updated Regions， Color OpenGL Fast Path Blue&lt;/p&gt;

&lt;p&gt;Color Immediately选项表示Instruments在做color-flush操作时取消10毫秒的延时。 
Flash Updated Regions选项用于用红色示标示出在屏幕上使用GPU计算绘制的图层。 
Color OpenGL Fast Path Blue选项用于用蓝色标示出在屏幕上由OpenGL compositor绘制的内容。&lt;/p&gt;

&lt;p&gt;这三个选项对图形性能的分析意义较小，通常仅作为参考。&lt;/p&gt;

&lt;h2 id=&quot;io&quot;&gt;文件和网络I/O&lt;/h2&gt;
&lt;p&gt;如果需要对app的文件和网络I/O情况做分析，可以用到这三个Instruments工具System Usage、File Activity和Network。&lt;/p&gt;

&lt;p&gt;工具System Usage可以统计出运行状态下应用的文件和网络IO操作数据。例如我们发现应用启动后又一个峰值，这可能存在问题，我们可以利用System Usage工具的详细信息栏查看应用是由于对哪些文件的读写操作导致了峰值。&lt;/p&gt;

&lt;p&gt;工具File Activity只能在模拟器中运行，因此数据采集可能不是非常准确。它同样可以详细给出读取的文件属性、大小、载入时间等信息，适合与System Usage配合使用。
&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015-7_13_app/9.png?raw=true&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Network工具则可以采集到应用的TCP/IP和UDP的使用信息(传输的数据量、当前所有TCP连接等)，用得不多，做网络使用状况分析时用用还行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015-7_13_app/10.png?raw=true&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;更多阅读
涉及iOS App性能的知识很多，上面只是冰山一角，重点推荐WWDC的session。&lt;/p&gt;

&lt;p&gt;WWDC 2012:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;406: Adopting Automatic Reference Counting&lt;/li&gt;
  &lt;li&gt;238: iOS App Performance: Graphics and Animations&lt;/li&gt;
  &lt;li&gt;242: iOS App Performance: Memory&lt;/li&gt;
  &lt;li&gt;235: iOS App Performance: Responsiveness&lt;/li&gt;
  &lt;li&gt;409: Learning Instruments&lt;/li&gt;
  &lt;li&gt;706: Networking Best Practices&lt;/li&gt;
  &lt;li&gt;514: OpenGL ES Tools and Techniques&lt;/li&gt;
  &lt;li&gt;506: Optimizing 2D Graphics and Animation Performance&lt;/li&gt;
  &lt;li&gt;601: Optimizing Web Content in UIWebViews and Websites on iOS&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;225: Up and Running: Making a Great Impression with Every Launch
WWDC 2011:&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;105: Polishing Your App: Tips and tricks to improve the responsiveness and * performance&lt;/li&gt;
  &lt;li&gt;121: Understanding UIKit Rendering&lt;/li&gt;
  &lt;li&gt;131 performance optimization on iphone os&lt;/li&gt;
  &lt;li&gt;308: Blocks and Grand Central Dispatch in Practice&lt;/li&gt;
  &lt;li&gt;323: Introducing Automatic Reference Counting&lt;/li&gt;
  &lt;li&gt;312: iOS Performance and Power Optimization with Instruments
还有几篇不错的blog：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;http://oleb.net/blog/2011/11/ios5-tech-talk-michael-jurewitz-on-performance-measurement/&quot;&gt;http://oleb.net/blog/2011/11/ios5-tech-talk-michael-jurewitz-on-performance-measurement/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://eng.pulse.me/tips-for-improving-performance-of-your-ios-application/&quot;&gt;http://eng.pulse.me/tips-for-improving-performance-of-your-ios-application/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://robots.thoughtbot.com/post/36591648724/designing-for-ios-graphics-performance&quot;&gt;http://robots.thoughtbot.com/post/36591648724/designing-for-ios-graphics-performance&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.touchwonders.com/en/how-to-make-your-apps-feel-responsive-and-fast-part-2/&quot;&gt;http://www.touchwonders.com/en/how-to-make-your-apps-feel-responsive-and-fast-part-2/&lt;/a&gt;&lt;/p&gt;
</description>
				<pubDate>Mon, 13 Jul 2015 00:00:00 +0800</pubDate>
				<link>/2015/07/13/1iOS%20App%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html</link>
				<guid isPermaLink="true">/2015/07/13/1iOS%20App%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html</guid>
			</item>
		
			<item>
				<title>利用python爬妹子图</title>
				<description>&lt;p&gt;看了几天的python,发现python的语法确实简单。今天了解了一下python写爬虫，在这里记录一下。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015-7_30_python/1.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先 我们要下载pycharm&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.jetbrains.com/&quot;&gt;http://www.jetbrains.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后新建工程&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015-7_30_python/2.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第一种办法
目录如上 rexx.py 是使用正则表达式的方法  meizi.py是使用BeautifulSoup 三方库来实现解析jpg图片链接(早就听说python的第三库多且牛)&lt;/p&gt;

&lt;p&gt;正则表达式我在这就不多描述代码如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015-7_30_python/3.png?raw=true&quot; alt=&quot;&quot; /&gt;
首先里面用到了requests 这个库 。同理我们用时pip install requests安装&lt;/p&gt;

&lt;p&gt;source.txt 是我们把网页源码复制到txt里面解析的（人肉就是 手动操作哈哈！后面会介绍不用自己复制粘贴源码的操作）&lt;/p&gt;

&lt;p&gt;解析完txt文件 使用正则表达式匹配出我们的图片 最终把他写入文件就可以了&lt;/p&gt;

&lt;p&gt;第二种办法
在meizi.py文件里面 代码如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015-7_30_python/4.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里用到了自带的类库 urllib2 以及BeautifulSoup&lt;/p&gt;

&lt;p&gt;当然我们可以把代码复制到txt解析然后处理 但是现在我们现在直接urlopen一个链接&lt;/p&gt;

&lt;p&gt;然后使用BeautifulSoup 处理拿到soup&lt;/p&gt;

&lt;p&gt;使用soup.findall 就可以解析到想到的数据&lt;/p&gt;

&lt;p&gt;BeautifulSoup 的功能比较多大家可以自己百度一下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015-7_30_python/5.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是我随便爬的图片 好玩弄的  我这只是做个备注 可能有点乱 有时间会整理下思路，大家随便看看就好。&lt;/p&gt;
</description>
				<pubDate>Sun, 12 Jul 2015 00:00:00 +0800</pubDate>
				<link>/2015/07/12/2%E5%88%A9%E7%94%A8python%E7%88%AC%E5%A6%B9%E5%AD%90%E5%9B%BE.html</link>
				<guid isPermaLink="true">/2015/07/12/2%E5%88%A9%E7%94%A8python%E7%88%AC%E5%A6%B9%E5%AD%90%E5%9B%BE.html</guid>
			</item>
		
			<item>
				<title>使用Reveal 帮助你窥视别人的应用</title>
				<description>&lt;p&gt;今天看到一个微博是虾神的，贴出了一个照片，上面是ios届比较牛逼的前辈，内容是,你要是挖的动，你就牛逼。内容很简单，但是让我心中激荡起了无限涟漪，引用别人的一句话.比我牛逼X倍的人都在努力，你在干什么?&lt;br /&gt;
  回到正题，为了纪录自己的学历历程，坚持做到每天一篇吧。借鉴了那么多前辈们的经验，我想我怎么地也要做做贡献。今天有空看了下Reveal的使用。其实前辈们写的很好，但是可能他们比较高端，写的不够详细，我就啰嗦的写下我是怎么完成的吧。&lt;/p&gt;

&lt;p&gt;1.你要有一台真机，并且是越狱过的。我的是ios7.0系统的ipod touch,关于越狱我就不多说了，我记得1年前我用的盘古一键越狱..一键真的很无脑。&lt;/p&gt;

&lt;p&gt;2.会使用终端用终端，不会用的话 和我一样使用IfunBox(我比较low)。IfunBox的作用就是把一些文件导入到越狱手机里面去。其实就是要把Reveal里的framework导入到手机里。为啥要用IfunBox？因为手机的文件夹不像电脑.不是一样双击就能访问到.. ps：终端也可以完成，暂时不会，需要越狱。&lt;/p&gt;

&lt;p&gt;详细一点嘛就是先从&lt;a href=&quot;http://revealapp.com&quot;&gt;http://revealapp.com&lt;/a&gt; 下载Reveal，下载出来应该是酱紫的
	&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015_7_30_reveal/1.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后双击运行&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015_7_30_reveal/2.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;啥也没有的界面，接着我们就要使用ifunBox了。&lt;/p&gt;

&lt;p&gt;百度ifunbox for mac 下载 安装。
&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015_7_30_reveal/3.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;利用他就可以往手机的文件夹导入东西了。&lt;/p&gt;

&lt;p&gt;导入什么呢？当然是把Reveal里面的关键文件导入进去。&lt;/p&gt;

&lt;p&gt;首先进入啥也没有的Reveal&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015_7_30_reveal/4.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后点击红色标签部分 看下我们重要的东西是啥，就是两个文件了&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015_7_30_reveal/5.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;打开ifunbox
&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015_7_30_reveal/6.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这是我手机的文件夹路径，首先把Reveal.framework导入下面标红的路径里面去
&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015_7_30_reveal/7.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后把libReveal.dylib导入&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015_7_30_reveal/8.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后重启你的手机设备..不要问我怎么重启了…&lt;/p&gt;

&lt;p&gt;再打开你的Reveal就发现
&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015_7_30_reveal/9.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这个地方可以点了，进入别人的应用，我选择进入美团&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015_7_30_reveal/10.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这张图是我touch里美团的截图，效果就是这样了。
&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015_7_30_reveal/12.jpeg?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;第一次在简书写文章。用我的口头禅就是，我还是个菜鸡，希望大家能够海涵。&lt;/p&gt;

&lt;p&gt;附赠前面提到的图片一张，希望有朝一日你们也能和他们一样被贴在一块。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/2015_7_30_reveal/13.jpg?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如果还是不ok的 可以留言哈 第一次写,比较啰嗦..有问题大家一块解决。&lt;/p&gt;
</description>
				<pubDate>Sat, 11 Jul 2015 00:00:00 +0800</pubDate>
				<link>/2015/07/11/1-%E4%BD%BF%E7%94%A8Reveal.html</link>
				<guid isPermaLink="true">/2015/07/11/1-%E4%BD%BF%E7%94%A8Reveal.html</guid>
			</item>
		
			<item>
				<title>学习markdown</title>
				<description>&lt;h1 id=&quot;markdown&quot;&gt;学习markdown&lt;/h1&gt;

&lt;p&gt;既然第一篇是如何搭建博客，那么第二篇就写写平时我是如何写博客的吧.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;平时使用的是Markdwon写作，工具是&lt;a href=&quot;http://25.io/mou/&quot;&gt;Mou&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;每次创建好文件&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;2015-7-30-学习Markdown.md&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;之后就可以开始写作了界面就像这样&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;https://github.com/kekeYe/kekeYe.github.io/blob/master/assets/resources/customimages/destop.png?raw=true&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;然后我介绍下重要的Markdown语法吧。我才用一行代码，一行效果的形式，展示常用的语法。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;lets-begin&quot;&gt;&lt;strong&gt;&lt;em&gt;Let’s begin!&lt;/em&gt;&lt;/strong&gt;&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;1. 标签的用法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;# 我是大标题
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-1&quot;&gt;我是大标题&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;## 我也是大标题  
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;我也是大标题&lt;/h2&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;# 我是1级标题
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;section-3&quot;&gt;我是1级标题&lt;/h1&gt;

&lt;h2 id=&quot;section-4&quot;&gt;我是2级标题&lt;/h2&gt;

&lt;h3 id=&quot;section-5&quot;&gt;我是3级标题&lt;/h3&gt;

&lt;h4 id=&quot;section-6&quot;&gt;我是4级标题&lt;/h4&gt;

&lt;h5 id=&quot;section-7&quot;&gt;我是5级标题&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;###### 我是6级标题
&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id=&quot;section-8&quot;&gt;我是6级标题&lt;/h6&gt;

&lt;h2 id=&quot;section-9&quot;&gt;2. 黑体斜体的用法以及注释的用法&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;文字编辑这里可以是黑体 **我是黑体，还是注释**[^zhushi]. *我是斜体* , 点击小标签可以跳转到下面的解释
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文字编辑这里可以是黑体 &lt;strong&gt;我是黑体，还是注释&lt;/strong&gt;&lt;sup id=&quot;fnref:zhushi&quot;&gt;&lt;a href=&quot;#fn:zhushi&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;. &lt;em&gt;我是斜体&lt;/em&gt; , 点击小标签可以跳转到下面的解释&lt;/p&gt;

&lt;h2 id=&quot;section-10&quot;&gt;3. 引用说明和列表&lt;/h2&gt;

&lt;p&gt;下面介绍引用，使用&amp;gt; 可以让文章处于引用状态.列表可以用多种符号，这里用*&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 引用说明
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;引用说明&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;* 列表1
* * 列表2
* * * 列表3
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;列表1&lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;列表2&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;ul&gt;
          &lt;li&gt;列表3&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;两种结合起来&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; **注意了 引用列表开始了:**
&amp;gt; 
&amp;gt; * 列表1
&amp;gt;	* * 列表2
&amp;gt;	* * * 列表3
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;注意了 引用列表开始了:&lt;/strong&gt;&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;列表1
      &lt;ul&gt;
        &lt;li&gt;
          &lt;ul&gt;
            &lt;li&gt;列表2&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;
          &lt;ul&gt;
            &lt;li&gt;
              &lt;ul&gt;
                &lt;li&gt;列表3&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section-11&quot;&gt;4. 地址链接和图片链接&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;这是[百度](http://www.baidu.com)链接
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;链接&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是图片链接  
![](http://img3.imgtn.bdimg.com/it/u=1674609539,3404725154&amp;amp;fm=21&amp;amp;gp=0.jpg) 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是图片链接  	
&lt;img src=&quot;http://img3.imgtn.bdimg.com/it/u=1674609539,3404725154&amp;amp;fm=21&amp;amp;gp=0.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-12&quot;&gt;5. 代码高亮&lt;/h2&gt;

&lt;p&gt;来一段OC UIKit的代码&lt;/p&gt;

&lt;p&gt;&lt;code&gt;
#import &amp;lt;UIKit/UIKitDefines.h&amp;gt;  
#import &amp;lt;UIKit/UIAccelerometer.h&amp;gt;  
#import &amp;lt;UIKit/UIAccessibility.h&amp;gt;
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#import &amp;lt;UIKit/UIKitDefines.h&amp;gt;  
#import &amp;lt;UIKit/UIAccelerometer.h&amp;gt;  
#import &amp;lt;UIKit/UIAccessibility.h&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;帮助    &lt;code&gt;Cmd + /&lt;/code&gt; &lt;br /&gt;
同步文档    &lt;code&gt;Cmd + S&lt;/code&gt;&lt;br /&gt;
创建文档    &lt;code&gt;Cmd + Opt + N&lt;/code&gt;&lt;br /&gt;
最大化编辑器    &lt;code&gt;Cmd + Enter&lt;/code&gt;&lt;br /&gt;
预览文档 &lt;code&gt;Cmd + Opt + Enter&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-13&quot;&gt;6.分割线&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;------
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;***
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-14&quot;&gt;7.我学习的网站，和工具&lt;/h2&gt;

&lt;h5 id=&quot;markdown-1&quot;&gt;markdown在线工具&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://stackedit.io/editor&quot;&gt;https://stackedit.io/editor&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://typora.io&quot;&gt;http://typora.io&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://joehill.me/2015/07/27/2015-07-27-Markdown-Typora/&quot;&gt;http://joehill.me/2015/07/27/2015-07-27-Markdown-Typora/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://maxiang.info/#欢迎使用马克飞象&quot;&gt;http://maxiang.info/#欢迎使用马克飞象&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;chrome-extension://oknndfeeopgpibecfjljjfanledpbkog/index.html#&quot;&gt;chrome-extension://oknndfeeopgpibecfjljjfanledpbkog/index.html#
&lt;/a&gt;&lt;/p&gt;

&lt;h5 id=&quot;markdown-2&quot;&gt;markdown语法&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;http://wowubuntu.com/markdown/basic.html&quot;&gt;http://wowubuntu.com/markdown/basic.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ituring.com.cn/article/23&quot;&gt;http://www.ituring.com.cn/article/23&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://zipperary.com/2013/05/22/introduction-to-markdown/&quot;&gt;http://zipperary.com/2013/05/22/introduction-to-markdown/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.zhihu.com/question/20962496&quot;&gt;http://www.zhihu.com/question/20962496&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://www.360doc.com/content/12/0421/09/1016783_205350218.shtml&quot;&gt;http://www.360doc.com/content/12/0421/09/1016783_205350218.shtml&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;tips-&quot;&gt;8. 小tips 持续跟新&lt;/h2&gt;

&lt;p&gt;邮箱：&lt;a href=&quot;&amp;#109;&amp;#097;&amp;#105;&amp;#108;&amp;#116;&amp;#111;:&amp;#121;&amp;#101;&amp;#098;&amp;#105;&amp;#110;&amp;#051;&amp;#056;&amp;#051;&amp;#056;&amp;#057;&amp;#048;&amp;#050;&amp;#057;&amp;#064;&amp;#113;&amp;#113;&amp;#046;&amp;#099;&amp;#111;&amp;#109;&quot;&gt;&amp;#121;&amp;#101;&amp;#098;&amp;#105;&amp;#110;&amp;#051;&amp;#056;&amp;#051;&amp;#056;&amp;#057;&amp;#048;&amp;#050;&amp;#057;&amp;#064;&amp;#113;&amp;#113;&amp;#046;&amp;#099;&amp;#111;&amp;#109;&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:zhushi&quot;&gt;
      &lt;p&gt;&lt;strong&gt;我是解释，解释上面的内容&lt;/strong&gt;. &lt;a href=&quot;#fnref:zhushi&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
				<pubDate>Fri, 10 Jul 2015 00:00:00 +0800</pubDate>
				<link>/2015/07/10/0%E5%AD%A6%E4%B9%A0Markdown.html</link>
				<guid isPermaLink="true">/2015/07/10/0%E5%AD%A6%E4%B9%A0Markdown.html</guid>
			</item>
		
			<item>
				<title>纪录这个Blog是怎么诞生的</title>
				<description>&lt;h1 id=&quot;blog&quot;&gt;纪录这个Blog是怎么诞生的&lt;/h1&gt;

&lt;p&gt;大概每个博客的第一篇文章都是这个吧，接触iOS开发两年多了第一次想到写自己的博客,说来惭愧，一开始学别人搭建wordpress，心血来潮的买了个域名，一看到要备案神马的,果断放弃了。接着无意间发现&lt;a href=&quot;http://www.jianshu.com/users/b5709961b8e7/latest_articles&quot;&gt;简书&lt;/a&gt;是个不错的平台，全屏幕白色非常适合我的感觉，写了大概10多篇博客,发现 虽然他是个写博客不错的平台但是感觉还是不够符合我们程序员的style，想来想去还是觉得git更贴切了。废话了那么多,接下来 我就介绍下我是怎么搭建这个博客的吧。我也练习一下&lt;strong&gt;MarkDown&lt;/strong&gt;的各种方法。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;主要步骤&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;创建自己的github&lt;/li&gt;
  &lt;li&gt;新建gitpages&lt;/li&gt;
  &lt;li&gt;下载jekyll 找到符合自己Style的模版&lt;/li&gt;
  &lt;li&gt;修改模版 让自己看起来&lt;strong&gt;叼叼&lt;/strong&gt;的&lt;/li&gt;
  &lt;li&gt;clone自己的项目，编写第一篇博客&lt;/li&gt;
  &lt;li&gt;开始装逼吧！&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;接下来我就按着这个步骤,分别解释下这些操作。&lt;/p&gt;

&lt;p&gt;待跟新..&lt;/p&gt;

</description>
				<pubDate>Thu, 09 Jul 2015 00:00:00 +0800</pubDate>
				<link>/2015/07/09/how_to_start.html</link>
				<guid isPermaLink="true">/2015/07/09/how_to_start.html</guid>
			</item>
		
	</channel>
</rss>
